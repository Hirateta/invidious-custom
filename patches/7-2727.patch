From f54e247eb421795f7d7351516978e0f25e8a14f5 Mon Sep 17 00:00:00 2001
From: Samantaz Fox <coding@samantaz.fr>
Date: Sun, 12 Dec 2021 20:58:45 +0100
Subject: [PATCH] Extractors: Add support for shorts

Fixes #2708
---
 src/invidious/helpers/utils.cr         | 13 ++++++++++---
 src/invidious/yt_backend/extractors.cr | 22 ++++++++++++++++------
 2 files changed, 26 insertions(+), 9 deletions(-)

diff --git a/src/invidious/helpers/utils.cr b/src/invidious/helpers/utils.cr
index 603b4e1f3..7bbbcb922 100644
--- a/src/invidious/helpers/utils.cr
+++ b/src/invidious/helpers/utils.cr
@@ -21,10 +21,17 @@ def elapsed_text(elapsed)
 end
 
 def decode_length_seconds(string)
-  length_seconds = string.gsub(/[^0-9:]/, "").split(":").map &.to_i
+  length_seconds = string.gsub(/[^0-9:]/, "")
+  return 0_i32 if length_seconds.empty?
+
+  length_seconds = length_seconds.split(":").map { |x| x.to_i? || 0 }
   length_seconds = [0] * (3 - length_seconds.size) + length_seconds
-  length_seconds = Time::Span.new hours: length_seconds[0], minutes: length_seconds[1], seconds: length_seconds[2]
-  length_seconds = length_seconds.total_seconds.to_i
+
+  length_seconds = Time::Span.new(
+    hours: length_seconds[0],
+    minutes: length_seconds[1],
+    seconds: length_seconds[2]
+  ).total_seconds.to_i32
 
   return length_seconds
 end
diff --git a/src/invidious/yt_backend/extractors.cr b/src/invidious/yt_backend/extractors.cr
index 8398ca8e3..66b3cdef2 100644
--- a/src/invidious/yt_backend/extractors.cr
+++ b/src/invidious/yt_backend/extractors.cr
@@ -49,6 +49,9 @@ private module Parsers
       if author_info = item_contents.dig?("ownerText", "runs", 0)
         author = author_info["text"].as_s
         author_id = HelperExtractors.get_browse_id(author_info)
+      elsif author_info = item_contents.dig?("shortBylineText", "runs", 0)
+        author = author_info["text"].as_s
+        author_id = HelperExtractors.get_browse_id(author_info)
       else
         author = author_fallback.name
         author_id = author_fallback.id
@@ -68,18 +71,25 @@ private module Parsers
       view_count = item_contents.dig?("viewCountText", "simpleText").try &.as_s.gsub(/\D+/, "").to_i64? || 0_i64
       description_html = item_contents["descriptionSnippet"]?.try { |t| parse_content(t) } || ""
 
-      # The length information *should* only always exist in "lengthText". However, the legacy Invidious code
-      # extracts from "thumbnailOverlays" when it doesn't. More testing is needed to see if this is
-      # actually needed
+      # The length information generally exist in "lengthText". However, the info can sometimes
+      # be retrieved from "thumbnailOverlays" (e.g when the video is a "shorts" one).
       if length_container = item_contents["lengthText"]?
         length_seconds = decode_length_seconds(length_container["simpleText"].as_s)
       elsif length_container = item_contents["thumbnailOverlays"]?.try &.as_a.find(&.["thumbnailOverlayTimeStatusRenderer"]?)
         # This needs to only go down the `simpleText` path (if possible). If more situations came up that requires
         # a specific pathway then we should add an argument to extract_text that'll make this possible
-        length_seconds = length_container.dig?("thumbnailOverlayTimeStatusRenderer", "text", "simpleText")
+        length_text = length_container.dig?("thumbnailOverlayTimeStatusRenderer", "text", "simpleText")
 
-        if length_seconds
-          length_seconds = decode_length_seconds(length_seconds.as_s)
+        if length_text
+          length_text = length_text.as_s
+
+          if length_text == "SHORTS"
+            # Approximate length to one minute, as "shorts" generally don't exceed that length.
+            # TODO: Add some sort of metadata for the type of video (normal, live, premiere, shorts)
+            length_seconds = 60_i32
+          else
+            length_seconds = decode_length_seconds(length_text)
+          end
         else
           length_seconds = 0
         end
